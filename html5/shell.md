# Shell基础

记录shell基础学习。

[TOC]

## 1. 初识Linux shell

### 1.1  初探Linux

Linux可划分为四个部分：Linux内核，GNU工具，图形化桌面环境，应用软件。

#### Linux内核

Linux系统的核心是**内核** 。内核控制着计算机系统上的所有硬件和软件，在必要时分配硬件，并根据需要执行软件。主要负责以下四种功能：系统内存管理，软件程序管理，硬件设备管理，文件系统管理

<b>系统内存管理</b>

操作系统内核的主要功能之一就是内存管理。内核不仅管理服务器上的可用物理内存，还可以创建和管理虚拟内存（即实际并不存在的内存）。

内核通过硬盘上的存储空间来实现虚拟内存，这块区域称为**交换空间** （swap space）。内核不断地在交换空间和实际的物理内存之间反复交换虚拟内存中的内容。

<b>软件管理程序</b>

Linux操作系统将运行中的程序称为**进程** 。进程可以在前台运行，将输出显示在屏幕上，也可以在后台运行，隐藏到幕后。内核控制着Linux系统如何管理运行在系统上的所有进程。

内核创建了第一个进程（称为**init进程** ）来启动系统上所有其他进程。当内核启动时，它会将init进程加载到虚拟内存中。内核在启动任何其他进程时，都会在虚拟内存中给新进程分配一块专有区域来存储该进程用到的数据和代码。

<b>硬件设备管理</b>

内核的另一职责是管理硬件设备。任何Linux系统需要与之通信的设备，都需要在内核代码中加入其驱动程序代码。驱动程序代码相当于应用程序和硬件设备的中间人，允许内核与设备之间交换数据。

<b>文件系统管理</b>

不同于其他一些操作系统，Linux内核支持通过不同类型的文件系统从硬盘中读写数据。除了自有的诸多文件系统外，Linux还支持从其他操作系统（比如Microsoft Windows）采用的文件系统中读写数据。内核必须在编译时就加入对所有可能用到的文件系统的支持。

| **文件系统** | **描述**                                          |
| :----------- | :------------------------------------------------ |
| ext          | Linux扩展文件系统，最早的Linux文件系统            |
| ext2         | 第二扩展文件系统，在ext的基础上提供了更多的功能   |
| ext3         | 第三扩展文件系统，支持日志功能                    |
| ext4         | 第四扩展文件系统，支持高级日志功能                |
| hpfs         | OS/2高性能文件系统                                |
| jfs          | IBM日志文件系统                                   |
| iso9660      | ISO 9660文件系统（CD-ROM）                        |
| minix        | MINIX文件系统                                     |
| msdos        | 微软的FAT16                                       |
| ncp          | Netware文件系统                                   |
| nfs          | 网络文件系统                                      |
| ntfs         | 支持Microsoft NT文件系统                          |
| proc         | 访问系统信息                                      |
| ReiserFS     | 高级Linux文件系统，能提供更好的性能和硬盘恢复功能 |
| smb          | 支持网络访问的Samba SMB文件系统                   |
| sysv         | 较早期的Unix文件系统                              |
| ufs          | BSD文件系统                                       |
| umsdos       | 建立在msdos上的类Unix文件系统                     |
| vfat         | Windows 95文件系统（FAT32）                       |
| XFS          | 高性能64位日志文件系统                            |

#### GNU工具

除了由内核控制硬件设备外，操作系统还需要工具来执行一些标准功能，比如控制文件和程序。Linus在创建Linux系统内核时，并没有可用的系统工具。然而他很幸运，就在开发Linux内核的同时，有一群人正在互联网上共同努力，模仿Unix操作系统开发一系列标准的计算机系统工具。

GNU组织（GNU是GNU's Not Unix的缩写）开发了一套完整的Unix工具，但没有可以运行它们的内核系统。这些工具是在名为开源软件（open source software，OSS）的软件理念下开发的。

开源软件理念允许程序员开发软件，并将其免费发布。任何人都可以使用、修改该软件，或将该软件集成进自己的系统，无需支付任何授权费用。将Linus的Linux内核和GNU操作系统工具整合起来，就产生了一款完整的、功能丰富的免费操作系统。

<b>核心GNU工具</b>

GNU项目的主旨在于为Unix系统管理员设计出一套类似于Unix的环境。这个目标促使该项目移植了很多常见的Unix系统命令行工具。供Linux系统使用的这组核心工具被称为coreutils（core utilities）软件包。

GNU coreutils软件包由三部分构成：

- 用以处理文件的工具
- 用以操作文本的工具
- 用以管理进程的工具

这三组主要工具中的每一组都包含一些对Linux系统管理员和程序员至关重要的工具。

<b>shell</b>

GNU/Linux shell是一种特殊的交互式工具。它为用户提供了启动程序、管理文件系统中的文件以及运行在Linux系统上的进程的途径。shell的核心是命令行提示符。命令行提示符是shell负责交互的部分。它允许你输入文本命令，然后解释命令，并在内核中执行。

你也可以将多个shell命令放入文件中作为程序执行。这些文件被称作**shell脚本** 。你在命令行上执行的任何命令都可放进一个shell脚本中作为一组命令执行。这为创建那种需要把几个命令放在一起来工作的工具提供了便利。

| **shell** | **描述**                                                     |
| :-------- | :----------------------------------------------------------- |
| ash       | 一种运行在内存受限环境中简单的轻量级shell，但与bash shell完全兼容 |
| korn      | 一种与Bourne shell兼容的编程shell，但支持如关联数组和浮点运算等一些高级的编程特性 |
| tcsh      | 一种将C语言中的一些元素引入到shell脚本中的shell              |
| zsh       | 一种结合了bash、tcsh和korn的特性，同时提供高级编程特性、共享历史文件和主题化提示符的高级shell |

#### Linux桌面环境

<b>X Window系统</b>

有两个基本要素决定了视频环境：显卡和显示器。要在电脑上显示绚丽的画面，Linux软件就得知道如何与这两者互通。X Window软件是图形显示的核心部分。

X Window软件是直接和PC上的显卡及显示器打交道的底层程序。它控制着Linux程序如何在电脑上显示出漂亮的窗口和图形。

使用案例：

- Fedora Linux发行版采用了试验性的Wayland软件
- Ubuntu Linux发行版开发出了Mir显示服务器

<b>KDE桌面</b>

KDE（K Desktop Environment，K桌面环境）最初于1996年作为开源项目发布。它会生成一个类似于Microsoft Windows的图形化桌面环境。

使用案例：

- openSuSE Linux发行版上的KDE 4桌面

<b>GNOME桌面</b>

GNOME（the GNU Network Object Model Environment，GNU网络对象模型环境）是另一个流行的Linux桌面环境。

使用案例：

- Red Hat Linux
- CentOS Linux发行版

<b>Unity桌面</b>

如果你用的是Ubuntu Linux发行版，你会注意到它与KDE和GNOME桌面环境有些不一样。准确来说，这是因为负责开发Ubuntu的公司决定采用自己的一套叫作Unity的Linux桌面环境。

Unity桌面得名于该项目的目标——为工作站、平板电脑以及移动设备提供一致的桌面体验。不管你是在工作站还是在手机上使用Ubuntu，Unity桌面的使用方式都是一样的。

使用案例：

- Ubuntu Linux系统(LTS)

<b>其他桌面</b>

| **桌面** | **描述**                                                     |
| :------- | :----------------------------------------------------------- |
| Fluxbox  | 一个没有面板的轻型桌面，仅有一个可用来启动程序的弹出式菜单   |
| Xfce     | 和KDE很像的一个桌面，但少了很多图像以适应低内存环境          |
| JWM      | Joe的窗口管理器（Joe's Window Manager），非常适用于低内存低硬盘空间环境的超轻型桌面 |
| Fvwm     | 支持如虚拟桌面和面板等高级桌面功能，但能够在低内存环境中运行 |
| fvwm95   | 从fvwm衍生而来，但看起来更像是Windows 95桌面                 |

### 1.2  Linux发行版

我们将完整的Linux系统包称为**发行版** 。有很多不同的Linux发行版来满足可能存在的各种运算需求。大多数发行版是为某个特定用户群定制的，比如商业用户、多媒体爱好者、软件开发人员或者普通家庭用户。每个定制的发行版都包含了支持特定功能所需的各种软件包，比如为多媒体爱好者准备的音频和视频编辑软件，为软件开发人员准备的编译器和集成开发环境（IDE）。

不同的Linux发行版通常归类为3种：

- 完整的核心Linux发行版
- 特定用途的发行版
- LiveCD测试发行版

#### 核心Linux发行版

核心Linux发行版含有内核、一个或多个图形化桌面环境以及预编译好的几乎所有能见到的Linux应用。它提供了一站式的完整Linux安装。

| **发行版** | **描　　述**                                     |
| :--------- | :----------------------------------------------- |
| Slackware  | 最早的Linux发行版中的一员，在Linux极客中比较流行 |
| Red Hat    | 主要用于Internet服务器的商业发行版               |
| Fedora     | 从Red Hat分离出的家用发行版                      |
| Gentoo     | 为高级Linux用户设计的发行版，仅包含Linux源代码   |
| openSUSE   | 用于商用和家用的发行版                           |
| Debian     | 在Linux专家和商用Linux产品中流行的发行版         |

#### 特定用途的Linux发行版

Linux发行版的一个新子群已经出现了。它们通常基于某个主流发行版，但仅包含主流发行版中一小部分用于某种特定用途的应用程序。

除了提供特定软件外（比如仅为商业用户提供的办公应用），定制化发行版还尝试通过自动检测和自动配置常见硬件来帮助新手安装Linux。

| **发行版**  | **描述**                                         |
| :---------- | :----------------------------------------------- |
| CentOS      | 一款基于Red Hat企业版Linux源代码构建的免费发行版 |
| Ubuntu      | 一款用于学校和家庭的免费发行版                   |
| PCLinuxOS   | 一款用于家庭和办公的免费发行版                   |
| Mint        | 一款用于家庭娱乐的免费发行版                     |
| dyne:bolic  | 一款用于音频和MIDI应用的免费发行版               |
| Puppy Linux | 一款适用于老旧PC的小型免费发行版                 |

#### Linux liveCD发行版

Linux世界中一个相对较新的现象是可引导的Linux CD发行版的出现。它无需安装就可以看到Linux系统是什么样的。多数现代PC都能从CD启动，而不是必须从标准硬盘启动。基于这点，一些Linux发行版创建了含有Linux样本系统（称为Linux LiveCD）的可引导CD。由于单张CD容量的限制，这个样本并非完整的Linux系统，不过令人惊喜的是，你可以自己加入各种软件。结果就是，你可以通过CD来启动PC，并且无需在硬盘安装任何东西就能运行Linux发行版。

| **发行版**  | **描述**                                          |
| :---------- | :------------------------------------------------ |
| Knoppix     | 来自德国的一款Linux发行版，也是最早的LiveCD Linux |
| PCLinuxOS   | 一款成熟的LiveCD形式的Linux发行版                 |
| Ubuntu      | 为多种语言设计的世界级Linux项目                   |
| Slax        | 基于Slackware Linux的一款LiveCD Linux             |
| Puppy Linux | 为老旧PC设计的一款全功能Linux                     |

## 2. 走进shell

### 2.1  进入命令行

在图形化桌面出现之前，与Unix系统进行交互的唯一方式就是借助由shell所提供的文本**命令行界面** （command line interface，CLI）。CLI只能接受文本输入，也只能显示出文本和基本的图形输出。

<b>控制台终端</b>

进入CLI的一种方法是让Linux系统退出图形化桌面模式，进入文本模式。这样在显示器上就只有一个简单的shell CLI，跟图形化桌面出现以前一样。这种模式称作**Linux控制台** ，因为它仿真了早期的硬接线控制台终端，而且是一种同Linux系统交互的直接接口。

<b>图形化终端</b>

除了虚拟化终端控制台，还可以使用Linux图形化桌面环境中的**终端仿真包** 。终端仿真包会在一个桌面图形化窗口中模拟控制台终端的使用。图形化终端仿真只负责Linux图形化体验的一部分。完整的体验效果需要借助多个组件来实现，其中就包括图形化终端仿真软件（称为**客户端** ）。

| **名称**   | **例子**                               | **描述**                                             |
| :--------- | :------------------------------------- | :--------------------------------------------------- |
| 客户端     | 图形化终端仿真器，桌面环境，网络浏览器 | 请求图形化服务的应用                                 |
| 显示服务器 | Mir，Wayland Compositor，Xserver       | 负责管理显示（屏幕）和输入设备（键盘、鼠标、触摸屏） |
| 窗口管理器 | Compiz，Metacity，Kwin                 | 为窗口加入边框，提供窗口移动和管理功能               |
| 部件库     | Athenal（Xaw），X Intrinsics           | 为桌面环境中的客户端添加菜单以及外观项               |

### 2.2  **通过Linux控制台终端访问CLI**

在Linux的早期，在启动系统时你只会在显示器上看到一个登录提示符，除此之外就没别的了。之前说过，这就是Linux控制台。它是唯一可以为系统输入命令的地方。

在大多数Linux发行版中，你可以使用简单的按键组合来访问某个Linux虚拟控制台。通常必须按下Ctrl+Alt组合键，然后按功能键（F1~F7）进入要使用的虚拟控制台。功能键F1生成虚拟控制台1，F2键生成虚拟控制台2，F3键生成虚拟控制台3，F4键生成虚拟控制台4，依次类推。

> **说明** Linux发行版通常使用Ctrl+Alt组合键配合F1或F7来进入图形界面。Ubuntu使用F7，而RHEL则使用F1。最好还是测试一下自己所使用的发行版是如何进入图形界面的。

### 2.3  **通过图形化终端仿真访问CLI**

相较于虚拟化控制台终端，图形化桌面环境提供了更多访问CLI的方式。以下几种比较流行的仿真终端：

| **名称**         | **网址**                                                     |
| :--------------- | :----------------------------------------------------------- |
| Eterm            | [http://www.eterm.org](http://www.eterm.org/)                |
| Final Term       | [http://finalterm.org](http://finalterm.org/)                |
| GNOME Terminal   | https://help.gnome.org/users/gnome-terminal/stable           |
| Guake            | https://github.com/Guake/guake                               |
| Konsole Terminal | [http://konsole.kde.org](http://konsole.kde.org/)            |
| LillyTerm        | http://lilyterm.luna.com.tw/index.html                       |
| LXTerminal       | http://wiki.lxde.org/en/LXTerminal                           |
| mrxvt            | https://code.google.com/p/mrxvt                              |
| ROXTerm          | [http://roxterm.sourceforge.net](http://roxterm.sourceforge.net/) |
| rxvt             | http://sourceforge.net/projects/rxvt                         |
| rxvt-unicode     | http://software.schmorp.de/pkg/rxvt-unicode                  |
| Sakura           | https://launchpad.net/sakura                                 |
| st               | [http://st.suckless.org](http://st.suckless.org/)            |
| Terminator       | https://launchpad.net/terminator                             |
| Terminology      | http://www.enlightenment.org/p.php?p=about/terminology       |
| tilda            | http://tilda.sourceforge.net/tildaabout.php                  |
| UXterm           | http://manpages.ubuntu.com/manpages/gutsy/man1/uxterm.1.html |
| Wterm            | http://sourceforge.net/projects/wterm                        |
| xterm            | http://invisible-island.net/xterm                            |
| Xfce4 Terminal   | http://docs.xfce.org/apps/terminal/start                     |
| Yakuake          | http://extragear.kde.org/apps/yakuake                        |

## 3. 基本的bash shell命令

### 3.1  启动shell

GNU bash shell能提供对Linux系统的交互式访问。它是作为普通程序运行的，通常是在用户登录终端时启动。登录时系统启动的shell依赖于用户账户的配置。

/etc/passwd文件包含了所有系统用户账户列表以及每个用户的基本配置信息。以下是：

```
weiqiang:x:1000:1000::/home/weiqiang:/usr/bin/zsh
```

每个条目有七个字段，字段之间用冒号分隔, 最后一个字段上，该字段指定了用户使用的shell程序。

### 3.2  shell提示符

一旦启动了终端仿真软件包或者登录Linux虚拟控制台，你就会看到shell CLI提示符。如下：

```
[weiqiang@weiqiang ~]$
```

@符号前面的weiqiang是当前用户的名称，后面的是主机名称。

查看命令的手册页面：

```
$ man man
```

命令结果说明：

| **节**        | **描述**                   |
| :------------ | :------------------------- |
| Name          | 显示命令名和一段简短的描述 |
| Synopsis      | 命令的语法                 |
| Configuration | 命令配置信息               |
| Description   | 命令的一般性描述           |
| Options       | 命令选项描述               |
| Exit Status   | 命令的退出状态指示         |
| Return Value  | 命令的返回值               |
| Errors        | 命令的错误消息             |
| Environment   | 描述所使用的环境变量       |
| Files         | 命令用到的文件             |
| Versions      | 命令的版本信息             |
| Conforming To | 命名所遵从的标准           |
| Notes         | 其他有帮助的资料           |
| Bugs          | 提供提交bug的途径          |
| Example       | 展示命令的用法             |
| Authors       | 命令开发人员的信息         |
| Copyright     | 命令源代码的版权状况       |
| See Also      | 与该命令类型的其他命令     |

内容区域：

| **区域号** | **所涵盖的内容**         |
| :--------- | :----------------------- |
| 1          | 可执行程序或shell命令    |
| 2          | 系统调用                 |
| 3          | 库调用                   |
| 4          | 特殊文件                 |
| 5          | 文件格式与约定           |
| 6          | 游戏                     |
| 7          | 概览、约定及杂项         |
| 8          | 超级用户和系统管理员命令 |
| 9          | 内核例程                 |

### 3.3  浏览文件系统

<b>文件目录说明</b>

| **目录** | **用途**                                                  |
| :------- | :-------------------------------------------------------- |
| /        | 虚拟目录的根目录。通常不会在这里存储文件                  |
| /bin     | 二进制目录，存放许多用户级的GNU工具                       |
| /boot    | 启动目录，存放启动文件                                    |
| /dev     | 设备目录，Linux在这里创建设备节点                         |
| /etc     | 系统配置文件目录                                          |
| /home    | 主目录，Linux在这里创建用户目录                           |
| /lib     | 库目录，存放系统和应用程序的库文件                        |
| /media   | 媒体目录，可移动媒体设备的常用挂载点                      |
| /mnt     | 挂载目录，另一个可移动媒体设备的常用挂载点                |
| /opt     | 可选目录，常用于存放第三方软件包和数据文件                |
| /proc    | 进程目录，存放现有硬件及当前进程的相关信息                |
| /root    | root用户的主目录                                          |
| /sbin    | 系统二进制目录，存放许多GNU管理员级工具                   |
| /run     | 运行目录，存放系统运作时的运行时数据                      |
| /srv     | 服务目录，存放本地服务的相关文件                          |
| /sys     | 系统目录，存放系统硬件信息的相关文件                      |
| /tmp     | 临时目录，可以在该目录中创建和删除临时工作文件            |
| /usr     | 用户二进制目录，大量用户级的GNU工具和数据文件都存储在这里 |
| /var     | 可变目录，用以存放经常变化的文件，比如日志文件            |

<b>常用命令</b>

切换目录

```
$ cd  /home
```

基本列表

```
ls -al
```

### 3.4  处理文件

创建文件(文件的大小是零，因为`touch` 命令只创建了一个空文件)

```
$ touch test_one
```

改变访问时间

```
touch -a test_one
```

复制文件

```
cp source destination
```

递归地复制整个目录的内容

```
cp -R source destination
```

将文件和目录移动到另一个位置或重新命名(inode编号和时间戳保持不变)

```
$ mv fall  fzll
```

删除文件

```
$ rm -i fall
```

### 3.5  链接文件

链接文件是Linux文件系统的一个优势。如需要在系统上维护同一文件的两份或多份副本，除了保存多份单独的物理文件副本之外，还可以采用保存一份物理文件副本和多个虚拟副本的方法。这种虚拟的副本就称为**链接** 。链接是目录中指向文件真实位置的占位符。在Linux中有两种不同类型的文件链接：

- 符号链接
- 硬链接

**符号链接** 就是一个实实在在的文件，它指向存放在虚拟目录结构中某个地方的另一个文件。这两个通过符号链接在一起的文件，彼此的内容并不相同。

要为一个文件创建符号链接，原始文件必须事先存在。然后可以使用`ln` 命令以及`-s` 选项来创建符号链接。

```
$ ln -s data_file  sl_data_file
```

**硬链接** 会创建独立的虚拟文件，其中包含了原始文件的信息及位置。但是它们从根本上而言是同一个文件。引用硬链接文件等同于引用了源文件。要创建硬链接，原始文件也必须事先存在，只不过这次使用`ln` 命令时不再需要加入额外的参数了。

```
$ ln code_file  hl_code_file
```

### 3.6  处理目录

创建目录

```
$ mkdir New_Dir
```

同时创建多个目录和子目录，需要加入`-p` 参数

```
$ mkdir -p New_Dir/Sub_Dir/Under_Dir
```

删除目录(`rmdir` 命令只删除空目录)

```
$ rmdir New_Dir
```

删除其中的文件，然后再删除目录本身

```
$ rm -ri My_Dir
```

查看目录或文件类型

```
$ file my_file/my_dir
```

### 3.7  查看整个文件

查看整个文件

```
$ cat test1
```

`-n` 参数会给所有的行加上行号

```
$ cat -n test1
```

`-b` 给有文本的行加上行号

```
$ cat -b test1
```

`more` 查看文件

```
$ more test2
```

`less` 查看文件(`more` 的升级版，支持翻页搜索等)

```
$ less test2
```

### 3.8  查看部分文件

`tail` 命令会显示文件最后几行的内容（文件的“尾部”）。默认情况下，它会显示文件的末尾10行。

```
$ tail log_file
```

`-n` 参数来修改所显示的行数

```
$ tail -n 2 log_file
```

`-f` 参数是`tail` 命令的一个突出特性。它允许你在其他进程使用该文件时查看文件的内容。

```
$ tail -f log_file
```

`head` 命令，会显示文件开头那些行的内容。默认情况下，它会显示文件前10行的文本。

```
$ head log_file
```

`-n` 参数

```
$ head -5 log_file
```

## 4. 更多bash shell命令

### 4.1  监测程序

#### ps

`ps` 命令好比工具中的瑞士军刀，它能输出运行在系统上的所有程序的许多信息。默认情况下，`ps` 命令只会显示运行在当前控制台下的属于当前用户的进程。`ps` 命令虽然在收集运行在系统上的进程信息时非常有用，但也有不足之处：它只能显示某个特定时间点的信息。

<b>Unix风格的ps命令参数</b>

| **参数**          | **描述**                                                     |
| :---------------- | :----------------------------------------------------------- |
| `-A`              | 显示所有进程                                                 |
| `-N`              | 显示与指定参数不符的所有进程                                 |
| `-a`              | 显示除控制进程（session leader **1** ）和无终端进程外的所有进程 |
| `-d`              | 显示除控制进程外的所有进程                                   |
| `-e`              | 显示所有进程                                                 |
| `-C` `*cmdlist*`  | 显示包含在 `*cmdlist* `列表中的进程                          |
| `-G` `*grplist*`  | 显示组ID在 `*grplist* `列表中的进程                          |
| `-U` `*userlist*` | 显示属主的用户ID在 `*userlist* `列表中的进程                 |
| `-g` `*grplist*`  | 显示会话或组ID在 `*grplist* `列表中的进程 **2**              |
| `-p` `*pidlist*`  | 显示PID在 `*pidlist* `列表中的进程                           |
| `-s` `*sesslist*` | 显示会话ID在 `*sesslist* `列表中的进程                       |
| `-t` `*ttylist*`  | 显示终端ID在 `*ttylist* `列表中的进程                        |
| `-u` `*userlist*` | 显示有效用户ID在 `*userlist* `列表中的进程                   |
| `-F`              | 显示更多额外输出（相对 `-f` 参数而言）                       |
| `-O` `*format*`   | 显示默认的输出列以及 `*format* `列表指定的特定列             |
| `-M`              | 显示进程的安全信息                                           |
| `-c`              | 显示进程的额外调度器信息                                     |
| `-f`              | 显示完整格式的输出                                           |
| `-j`              | 显示任务信息                                                 |
| `-l`              | 显示长列表                                                   |
| `-o` `*format*`   | 仅显示由 `*format* `指定的列                                 |
| `-y`              | 不要显示进程标记（process flag，表明进程状态的标记）         |
| `-Z`              | 显示安全标签（security context） **3** 信息                  |
| `-H`              | 用层级格式来显示进程（树状，用来显示父进程）                 |
| `-n` `*namelist*` | 定义了 `WCHAN` 列显示的值                                    |
| `-w`              | 采用宽输出模式，不限宽度显示                                 |
| `-L`              | 显示进程中的线程                                             |
| `-V`              | 显示 `ps` 命令的版本号                                       |

查看系统上所有进程

```
$ ps -ef
```

- **UID** ：启动这些进程的用户。
- **PID** ：进程的进程ID。
- **PPID** ：父进程的进程号（如果该进程是由另一个进程启动的）。
- **C** ：进程生命周期中的CPU利用率。
- **STIME** ：进程启动时的系统时间。
- **TTY** ：进程启动时的终端设备。
- **TIME** ：运行进程需要的累计CPU时间。
- **CMD** ：启动的程序名称。

```
$ ps -l
```

- `F` ：内核分配给进程的系统标记。
- `S` ：进程的状态（O代表正在运行；S代表在休眠；R代表可运行，正等待运行；Z代表僵化，进程已结束但父进程已不存在；T代表停止）。
- `PRI` ：进程的优先级（越大的数字代表越低的优先级）。
- `NI` ：谦让度值用来参与决定优先级。
- `ADDR` ：进程的内存地址。
- `SZ` ：假如进程被换出，所需交换空间的大致大小。
- `WCHAN` ：进程休眠的内核函数的地址。

#### top

显示进程信息，它是实时显示的。

`top`**命令运行时的输出**

输出的第一部分显示的是系统的概况：第一行显示了当前时间、系统的运行时间、登录的用户数以及系统的平均负载。

平均负载有3个值：最近1分钟的、最近5分钟的和最近15分钟的平均负载。值越大说明系统的负载越高。由于进程短期的突发性活动，出现最近1分钟的高负载值也很常见，但如果近15分钟内的平均负载都很高，就说明系统可能有问题。

第二行显示了进程概要信息——`top` 命令的输出中将进程叫作**任务** （task）：有多少进程处在运行、休眠、停止或是僵化状态（僵化状态是指进程完成了，但父进程没有响应）。

下一行显示了CPU的概要信息。`top` 根据进程的属主（用户还是系统）和进程的状态（运行、空闲还是等待）将CPU利用率分成几类输出。

紧跟其后的两行说明了系统内存的状态。第一行说的是系统的物理内存：总共有多少内存，当前用了多少，还有多少空闲。后一行说的是同样的信息，不过是针对系统交换空间（如果分配了的话）的状态而言的。

最后一部分显示了当前运行中的进程的详细列表，有些列跟`ps` 命令的输出类似。

- **PID** ：进程的ID。
- **USER** ：进程属主的名字。
- **PR** ：进程的优先级。
- **NI** ：进程的谦让度值。
- **VIRT** ：进程占用的虚拟内存总量。
- **RES** ：进程占用的物理内存总量。
- **SHR** ：进程和其他进程共享的内存总量。
- **S** ：进程的状态（D代表可中断的休眠状态，R代表在运行状态，S代表休眠状态，T代表跟踪状态或停止状态，Z代表僵化状态）。
- **%CPU** ：进程使用的CPU时间比例。
- **%MEM** ：进程使用的内存占可用内存的比例。
- **TIME+** ：自进程启动到目前为止的CPU时间总量。
- **COMMAND** ：进程所对应的命令行名称，也就是启动的程序名。

默认情况下，`top` 命令在启动时会按照`%CPU` 值对进程排序。

<b>结束进程</b>

作为系统管理员，很重要的一个技能就是知道何时以及如何结束一个进程。有时进程挂起了，只需要动动手让进程重新运行或结束就行了。但有时，有的进程会耗尽CPU且不释放资源。在这两种情景下，你就需要能控制进程的命令。Linux沿用了Unix进行进程间通信的方法。

在Linux中，进程之间通过**信号** 来通信。进程的信号就是预定义好的一个消息，进程能识别它并决定忽略还是作出反应。进程如何处理信号是由开发人员通过编程来决定的。大多数编写完善的程序都能接收和处理标准Unix进程信号。

<b>Linux进程信号</b>

| **信号** | **名称** | **描述**                         |
| :------- | :------- | :------------------------------- |
| `1`      | `HUP`    | 挂起                             |
| `2`      | `INT`    | 中断                             |
| `3`      | `QUIT`   | 结束运行                         |
| `9`      | `KILL`   | 无条件终止                       |
| `11`     | `SEGV`   | 段错误                           |
| `15`     | `TERM`   | 尽可能终止                       |
| `17`     | `STOP`   | 无条件停止运行，但不终止         |
| `18`     | `TSTP`   | 停止或暂停，但继续在后台运行     |
| `19`     | `CONT`   | 在 `STOP` 或 `TSTP` 之后恢复执行 |

#### kill

`kill` 命令可通过进程ID（PID）给进程发信号。默认情况下，`kill` 命令会向命令行中列出的全部PID发送一个`TERM` 信号。遗憾的是，你只能用进程的PID而不能用命令名，所以`kill` 命令有时并不好用。

要发送进程信号，你必须是进程的属主或登录为root用户。

```
# kill 3940
# kill -s HUP 3940
```

#### killall

`killall` 命令非常强大，它支持通过进程名而不是PID来结束进程。`killall` 命令也支持通配符，这在系统因负载过大而变得很慢时很有用。

```
# killall http*
```

### 4.2  监测磁盘空间

#### mount

Linux上用来挂载媒体的命令叫作`mount` 。默认情况下，`mount` 命令会输出当前系统上挂载的设备列表。

`mount` 命令提供如下四部分信息：

- 媒体的设备文件名
- 媒体挂载到虚拟目录的挂载点
- 文件系统类型
- 已挂载媒体的访问状态

```
# mount -t type device directory
```

`type` 参数指定了磁盘被格式化的文件系统类型。

```
# mount -t vfat /dev/sdb1 /media/disk
```

<b>mount参数</b>

| **参数**      | **描述**                                                   |
| :------------ | :--------------------------------------------------------- |
| `-a`          | 挂载/etc/fstab文件中指定的所有文件系统                     |
| `-f`          | 使 `mount` 命令模拟挂载设备，但并不真的挂载                |
| `-F`          | 和 `-a` 参数一起使用时，会同时挂载所有文件系统             |
| `-v`          | 详细模式，将会说明挂载设备的每一步                         |
| `-I`          | 不启用任何/sbin/mount.filesystem下的文件系统帮助文件       |
| `-l`          | 给ext2、ext3或XFS文件系统自动添加文件系统标签              |
| `-n`          | 挂载设备，但不注册到/etc/mtab已挂载设备文件中              |
| `-p` `*num*`  | 进行加密挂载时，从文件描述符 `*num* `中获得密码短语        |
| `-s`          | 忽略该文件系统不支持的挂载选项                             |
| `-r`          | 将设备挂载为只读的                                         |
| `-w`          | 将设备挂载为可读写的（默认参数）                           |
| `-L label`    | 将设备按指定的 `*label* `挂载                              |
| `-U` `*uuid*` | 将设备按指定的 `*uuid* `挂载                               |
| `-O`          | 和 `-a` 参数一起使用，限制命令只作用到特定的一组文件系统上 |
| `-o`          | 给文件系统添加特定的选项                                   |

#### umount

从Linux系统上移除一个可移动设备时，不能直接从系统上移除，而应该先卸载。

```
# umount [directory | device ]
```

#### df

`df` 命令可以让你很方便地查看所有已挂载磁盘的使用情况。

```
$ df -h
```

命令输出如下：

- 设备的设备文件位置
- 能容纳多少个1024字节大小的块
- 已用了多少个1024字节大小的块
- 还有多少个1024字节大小的块可用
- 已用空间所占的比例
- 设备挂载到了哪个挂载点上

#### du

`du` 命令可以显示某个特定目录（默认情况下是当前目录）的磁盘使用情况。这一方法可用来快速判断系统上某个目录下是不是有超大文件。

默认情况下，`du` 命令会显示当前目录下所有的文件、目录和子目录的磁盘使用情况，它会以磁盘块为单位来表明每个文件或目录占用了多大存储空间。对标准大小的目录来说，这个输出会是一个比较长的列表。这个列表是从目录层级的最底部开始，然后按文件、子目录、目录逐级向上。

```
$ du -h
```

参数说明：

- `-c` ：显示所有已列出文件总的大小。
- `-h` ：按用户易读的格式输出大小，即用K替代千字节，用M替代兆字节，用G替代吉字节。
- `-s` ：显示每个输出参数的总计。

### 4.3  处理数据文件

#### sort

`sort` 命令是对数据进行排序的。默认情况下，`sort` 命令按照会话指定的默认语言的排序规则对文本文件中的数据行排序。

```
$ sort file1
```

`-n` 参数，`sort` 命令把数字识别成数字而不是字符，并且按值排序。

```
$ sort -n file2
```

`-M` 参数，`sort` 命令就能识别三字符的月份名，并相应地排序。

```
$ sort -M file3
```

<b>其他参数</b>

| **单破折线** | **双破折线**                        | **描述**                                                     |
| :----------- | :---------------------------------- | :----------------------------------------------------------- |
| `-b`         | `--ignore-leading-blanks`           | 排序时忽略起始的空白                                         |
| `-C`         | `--check=quiet`                     | 不排序，如果数据无序也不要报告                               |
| `-c`         | `--check`                           | 不排序，但检查输入数据是不是已排序；未排序的话，报告         |
| `-d`         | `--dictionary-order`                | 仅考虑空白和字母，不考虑特殊字符                             |
| `-f`         | `--ignore-case`                     | 默认情况下，会将大写字母排在前面；这个参数会忽略大小写       |
| `-g`         | `--general-number-sort`             | 按通用数值来排序（跟 `-n` 不同，把值当浮点数来排序，支持科学计数法表示的值） |
| `-i`         | `--ignore-nonprinting`              | 在排序时忽略不可打印字符                                     |
| `-k`         | `--key=` `*POS1* ``[,` `*POS2* ``]` | 排序从POS1位置开始；如果指定了POS2的话，到POS2位置结束       |
| `-M`         | `--month-sort`                      | 用三字符月份名按月份排序                                     |
| `-m`         | `--merge`                           | 将两个已排序数据文件合并                                     |
| `-n`         | `--numeric-sort`                    | 按字符串数值来排序（并不转换为浮点数）                       |
| `-o`         | `--output=` `*file*`                | 将排序结果写出到指定的文件中                                 |
| `-R`         | `--random-sort`                     | 按随机生成的散列表的键值排序                                 |
|              | `--random-source=` `*FILE*`         | 指定 `-R` 参数用到的随机字节的源文件                         |
| `-r`         | `--reverse`                         | 反序排序（升序变成降序）                                     |
| `-S`         | `--buffer-size=` `*SIZE*`           | 指定使用的内存大小                                           |
| `-s`         | `--stable`                          | 禁用最后重排序比较                                           |
| `-T`         | `--temporary-directory=` `*DIR*`    | 指定一个位置来存储临时工作文件                               |
| `-t`         | `--field-separator=` `*SEP*`        | 指定一个用来区分键位置的字符                                 |
| `-u`         | `--unique`                          | 和 `-c` 参数一起使用时，检查严格排序；不和 `-c` 参数一起用时，仅输出第一例相似的两行 |
| `-z`         | `--zero-terminated`                 | 用NULL字符作为行尾，而不是用换行符                           |

综合应用：

```
$ du -sh * | sort -nr
```

#### grep

搜索数据。

使用格式如下：

```
$ grep [options] pattern [file]
```

`-n` 参数，如果要显示匹配模式的行所在的行号。

```
$ grep -n t file1
```

`-c` 参数，有多少行含有匹配的模式。

```
$ grep -c t file1
```

`-e` 参数，指定多个匹配模式。

```
$ grep -e t -e f file1
```

采用正则表达

```
$ grep [tf] file1
```

<b>Linux压缩工具</b>

| **工具**   | **文件扩展名** | **描述**                                          |
| :--------- | :------------- | :------------------------------------------------ |
| `bzip2`    | .bz2           | 采用Burrows-Wheeler块排序文本压缩算法和霍夫曼编码 |
| `compress` | .Z             | 最初的Unix文件压缩工具，已经快没人用了            |
| `gzip`     | .gz            | GNU压缩工具，用Lempel-Ziv编码                     |
| `zip`      | .zip           | Windows上PKZIP工具的Unix实现                      |

#### zip

压缩文件或目录。

把一个文件abc.txt和一个目录dir1压缩成为yasuo.zip

```
$ zip -r yasuo.zip abc.txt dir1
```

解压

```
$ unzip yasuo.zip
```

#### gzip

- `gzip` ：用来压缩文件。
- `gzcat` ：用来查看压缩过的文本文件的内容。
- `gunzip` ：用来解压文件。

压缩

```
$ gzip myprog
$ gzip my*
```

#### tar

归档数据。

`tar` 命令的格式：

```
tar function [options] object1 object2 ...
```

`function` 参数:

| **功能** | **长名称**      | **描述**                                                     |
| :------- | :-------------- | :----------------------------------------------------------- |
| `-A`     | `--concatenate` | 将一个已有tar归档文件追加到另一个已有tar归档文件             |
| `-c`     | `--create`      | 创建一个新的tar归档文件                                      |
| `-d`     | `--diff`        | 检查归档文件和文件系统的不同之处                             |
|          | `--delete`      | 从已有tar归档文件中删除                                      |
| `-r`     | `--append`      | 追加文件到已有tar归档文件末尾                                |
| `-t`     | `--list`        | 列出已有tar归档文件的内容                                    |
| `-u`     | `--update`      | 将比tar归档文件中已有的同名文件新的文件追加到该tar归档文件中 |
| `-x`     | `--extract`     | 从已有tar归档文件中提取文件                                  |

`tar` 命令选项

| **选项**      | **描述**                              |
| :------------ | :------------------------------------ |
| `-C` `*dir*`  | 切换到指定目录                        |
| `-f` `*file*` | 输出结果到文件或设备 `*file*`         |
| `-j`          | 将输出重定向给 `bzip2` 命令来压缩内容 |
| `-p`          | 保留所有文件权限                      |
| `-v`          | 在处理文件时显示文件                  |
| `-z`          | 将输出重定向给 `gzip` 命令来压缩内容  |

创建了名为test.tar的归档文件

```
tar -cvf test.tar test/ test2/
```

列出tar文件test.tar的内容（但并不提取文件）

```
tar -tf test.tar
```

从test.tar中提取内容

```
tar -xvf test.tar
```

## 5. 理解shell

### 5.1  shell的父子关系

用于登录某个虚拟控制器终端或在GUI中运行终端仿真器时所启动的默认的交互shell，是一个**父shell** 。

在CLI提示符后输入`/bin/bash` 命令或其他等效的`bash` 命令时，会创建一个新的shell程序。这个shell程序被称为**子shell** 。

退出子shell

```
$ exit
```

查看父子进程的关系

```
ps -f
```

 bash命令行参数

| **参数**    | **描述**                                    |
| :---------- | :------------------------------------------ |
| `-c string` | 从 `string` 中读取命令并进行处理            |
| `-i`        | 启动一个能够接收用户输入的交互shell         |
| `-l`        | 以登录shell的形式启动                       |
| `-r`        | 启动一个受限shell，用户会被限制在默认目录中 |
| `-s`        | 从标准输入中读取命令                        |

在一行中指定要依次运行的一系列命令。这可以通过命令列表来实现，只需要在命令之间加入分号（;）即可。

```
$ pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls
```

在上面的例子中，所有的命令依次执行，不存在任何问题。不过这并不是进程列表。命令列表要想成为进程列表，这些命令必须包含在括号里。

```
$ (pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls)
```

### 5.2  后台模式

在后台模式中运行命令可以在处理命令的同时让出CLI，以供他用。

#### &

要想将命令置入后台模式，可以在命令末尾加上字符`&` 。

```
$ sleep 3000&
```

当它被置入后台，在shell CLI提示符返回之前，会出现两条信息。第一条信息是显示在方括号中的**后台作业** （background job）号（`1` ）。第二条是后台作业的进程ID（`2396` ）。

```
[1] 2396
```

#### jobs

`jobs` 命令可以显示出当前运行在后台模式中的所有用户的进程（作业）。

```
$ jobs
```

#### coproc

协程命令，协程可以同时做两件事。它在后台生成一个子shell，并在这个子shell中执行命令。

```
$ coproc sleep 10
```

jobs查看结果

```
[1]+  Running                 coproc COPROC sleep 10 &
```

### 5.3  shell的内建命令

#### 外部命令

外部命令，有时候也被称为文件系统命令，是存在于bash shell之外的程序。它们并不是shell程序的一部分。外部命令程序通常位于/bin、/usr/bin、/sbin或/usr/sbin中。

`ps` 就是一个外部命令。你可以使用`which` 和`type` 命令找到它。

```
$ which ps
```

```
$ type -a ps
```

当外部命令执行时，会创建出一个子进程。这种操作被称为**衍生** （forking）。

```
$ ps -f
UID        PID  PPID  C STIME TTY          TIME CMD
christi+  2743  2742  0 17:09 pts/9    00:00:00 -bash
christi+  2801  2743  0 17:16 pts/9    00:00:00 ps -f
```

#### 内建命令

**内建命令** 和外部命令的区别在于前者不需要使用子进程来执行。它们已经和shell编译成了一体，作为shell工具的组成部分存在。不需要借助外部程序文件来运行。

`cd` 和`exit` 命令都内建于bash shell。可以利用`type` 命令来了解某个命令是否是内建的。

```
$ type cd
cd is a shell builtin

$ type exit
exit is a shell builtin
```

#### history

查看最近用过的命令列表

```
$ history
```

当输入`!!` 时，bash首先会显示出从shell的历史记录中唤回的命令。然后执行该命令

```
$ !!
```

强制将命令历史记录写入.bash_history文件

```
$ history -a
```

#### alias

命令别名允许你为常用的命令（及其参数）创建另一个名称，从而将输入量减少到最低。

要查看当前可用的别名

```
$ alias -p
```

创建属于自己的别名

```
$ alias li='ls -li'
```

> 注意: 因为命令别名属于内部命令，一个别名仅在它所被定义的shell进程中才有效。

## 6.  Linux环境变量

bash shell用一个叫作**环境变量** （environment variable）的特性来存储有关shell会话和工作环境的信息（这也是它们被称作环境变量的原因）。这项特性允许你在内存中存储数据，以便程序或shell中运行的脚本能够轻松访问到它们。

### 6.1  全局变量和环境变量

#### 全局环境变量

全局环境变量对于shell会话和所有生成的子shell都是可见的。

查看全局变量

```
$ printenv
```

获取某个变量的值

```
$ printenv HOME
或
$ echo $HOME
```

#### 局部变量

局部环境变量只能在定义它们的进程中可见。

`set` 命令会显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量以及用户定义变量。

```
$ set
```

所有通过`printenv` 命令能看到的全局环境变量都出现在了`set` 命令的输出中。但在`set` 命令的输出中还有其他一些环境变量，即局部环境变量和用户定义变量。

命令`env` 、`printenv` 和`set` 之间的差异很细微。`set` 命令会显示出全局变量、局部变量以及用户定义变量。它还会按照字母顺序对结果进行排序。`env` 和`printenv` 命令同`set` 命令的区别在于前两个命令不会对变量排序，也不会输出局部变量和用户定义变量。

### 6.2  设置用户定义变量

通过等号给环境变量赋值，值可以是数值或字符串

```
$ my_variable=Hello
```

引用`my_variable` 环境变量的值，只要通过`$my_variable` 引用即可

```
$ echo $my_variable
```

> > 所有的环境变量名均使用大写字母，这是bash shell的标准惯例。如果是你自己创建的局部变量或是shell脚本，请使用小写字母。变量名区分大小写。在涉及用户定义的局部变量时坚持使用小写字母，这能够避免重新定义系统环境变量可能带来的灾难。
>
> 记住，变量名、等号和值之间没有空格，这一点非常重要。

<b>创建全局变量</b>: 创建全局环境变量的方法是先创建一个局部环境变量，然后再把它导出到全局环境中。

```
$ my_variable="I am Global now"

$ export my_variable
```

> 在定义并导出变量`my_variable` 后，`bash` 命令启动了一个子shell。在这个子shell中能够正确显示出全局环境变量`my_variable` 的值。子shell随后改变了这个变量的值。但是这种改变仅在子shell中有效，并不会被反映到父shell中。
>
> 子shell甚至无法使用`export` 命令改变父shell中全局环境变量的值。

删除环境变量

```
$ unset my_variable
```

### 6.3  默认的shell环境变量

默认情况下，bash shell会用一些特定的环境变量来定义系统环境。这些变量在你的Linux系统上都已经设置好了，只管放心使用。

| **变量**                | **描述**                                                     |
| :---------------------- | :----------------------------------------------------------- |
| `BASH`                  | 当前shell实例的全路径名                                      |
| `BASH_ALIASES`          | 含有当前已设置别名的关联数组                                 |
| `BASH_ARGC`             | 含有传入子函数或shell脚本的参数总数的数组变量                |
| `BASH_ARCV`             | 含有传入子函数或shell脚本的参数的数组变量                    |
| `BASH_CMDS`             | 关联数组，包含shell执行过的命令的所在位置                    |
| `BASH_COMMAND`          | shell正在执行的命令或马上就执行的命令                        |
| `BASH_ENV`              | 设置了的话，每个bash脚本会在运行前先尝试运行该变量定义的启动文件 |
| `BASH_EXECUTION_STRING` | 使用 `bash -c` 选项传递过来的命令                            |
| `BASH_LINENO`           | 含有当前执行的shell函数的源代码行号的数组变量                |
| `BASH_REMATCH`          | 只读数组，在使用正则表达式的比较运算符=~进行肯定匹配（positive match）时，包含了匹配到的模式和子模式 |
| `BASH_SOURCE`           | 含有当前正在执行的shell函数所在源文件名的数组变量            |
| `BASH_SUBSHELL`         | 当前子shell环境的嵌套级别（初始值是0）                       |
| `BASH_VERSINFO`         | 含有当前运行的bash shell的主版本号和次版本号的数组变量       |
| `BASH_VERSION`          | 当前运行的bash shell的版本号                                 |
| `BASH_XTRACEFD`         | 若设置成了有效的文件描述符（ `0` 、 `1` 、 `2` ），则 `'set -x'` 调试选项生成的跟踪输出可被重定向。通常用来将跟踪输出到一个文件中 |
| `BASHOPTS`              | 当前启用的bash shell选项的列表                               |
| `BASHPID`               | 当前bash进程的PID                                            |
| `COLUMNS`               | 当前bash shell实例所用终端的宽度                             |
| `COMP_CWORD`            | `COMP_WORDS` 变量的索引值，后者含有当前光标的位置            |
| `COMP_LINE`             | 当前命令行                                                   |
| `COMP_POINT`            | 当前光标位置相对于当前命令起始的索引                         |
| `COMP_KEY`              | 用来调用shell函数补全功能的最后一个键                        |
| `COMP_TYPE`             | 一个整数值，表示所尝试的补全类型，用以完成shell函数补全      |
| `COMP_WORDBREAKS`       | Readline库中用于单词补全的词分隔字符                         |
| `COMP_WORDS`            | 含有当前命令行所有单词的数组变量                             |
| `COMPREPLY`             | 含有由shell函数生成的可能填充代码的数组变量                  |
| `COPROC`                | 占用未命名的协进程的I/O文件描述符的数组变量                  |
| `DIRSTACK`              | 含有目录栈当前内容的数组变量                                 |
| `EMACS`                 | 设置为 `'t'` 时，表明emacs shell缓冲区正在工作，而行编辑功能被禁止 |
| `ENV`                   | 如果设置了该环境变量，在bash shell脚本运行之前会先执行已定义的启动文件（仅用于当bash shell以POSIX模式被调用时） |
| `EUID`                  | 当前用户的有效用户ID（数字形式）                             |
| `FCEDIT`                | 供 `fc` 命令使用的默认编辑器                                 |
| `FIGNORE`               | 在进行文件名补全时可以忽略后缀名列表，由冒号分隔             |
| `FUNCNAME`              | 当前执行的shell函数的名称                                    |
| `FUNCNEST`              | 当设置成非零值时，表示所允许的最大函数嵌套级数（一旦超出，当前命令即被终止） |
| `GLOBIGNORE`            | 冒号分隔的模式列表，定义了在进行文件名扩展时可以忽略的一组文件名 |
| `GROUPS`                | 含有当前用户属组列表的数组变量                               |
| `histchars`             | 控制历史记录扩展，最多可有3个字符                            |
| `HISTCMD`               | 当前命令在历史记录中的编号                                   |
| `HISTCONTROL`           | 控制哪些命令留在历史记录列表中                               |
| `HISTFILE`              | 保存shell历史记录列表的文件名（默认是.bash_history）         |
| `HISTFILESIZE`          | 最多在历史文件中存多少行                                     |
| `HISTTIMEFORMAT`        | 如果设置了且非空，就用作格式化字符串，以显示bash历史中每条命令的时间戳 |
| `HISTIGNORE`            | 由冒号分隔的模式列表，用来决定历史文件中哪些命令会被忽略     |
| `HISTSIZE`              | 最多在历史文件中存多少条命令                                 |
| `HOSTFILE`              | shell在补全主机名时读取的文件名称                            |
| `HOSTNAME`              | 当前主机的名称                                               |
| `HOSTTYPE`              | 当前运行bash shell的机器                                     |
| `IGNOREEOF`             | shell在退出前必须收到连续的 `EOF` 字符的数量（如果这个值不存在，默认是 `1` ） |
| `INPUTRC`               | Readline初始化文件名（默认是.inputrc）                       |
| `LANG`                  | shell的语言环境类别                                          |
| `LC_ALL`                | 定义了一个语言环境类别，能够覆盖 `LANG` 变量                 |
| `LC_COLLATE`            | 设置对字符串排序时用的排序规则                               |
| `LC_CTYPE`              | 决定如何解释出现在文件名扩展和模式匹配中的字符               |
| `LC_MESSAGES`           | 在解释前面带有 `$` 的双引号字符串时，该环境变量决定了所采用的语言环境设置 |
| `LC_NUMERIC`            | 决定着格式化数字时采用的语言环境设置                         |
| `LINENO`                | 当前执行的脚本的行号                                         |
| `LINES`                 | 定义了终端上可见的行数                                       |
| `MACHTYPE`              | 用“CPU-公司-系统”（CPU-company-system）格式定义的系统类型    |
| `MAPFILE`               | 一个数组变量，当 `mapfile` 命令未指定数组变量作为参数时，它存储了 `mapfile` 所读入的文本 |
| `MAILCHECK`             | shell查看新邮件的频率（以秒为单位，默认值是 `60` ）          |
| `OLDPWD`                | shell之前的工作目录                                          |
| `OPTERR`                | 设置为1时，bash shell会显示 `getopts` 命令产生的错误         |
| `OSTYPE`                | 定义了shell所在的操作系统                                    |
| `PIPESTATUS`            | 含有前台进程的退出状态列表的数组变量                         |
| `POSIXLY_CORRECT`       | 设置了的话，bash会以POSIX模式启动                            |
| `PPID`                  | bash shell父进程的PID                                        |
| `PROMPT_COMMAND`        | 设置了的话，在命令行主提示符显示之前会执行这条命令           |
| `PROMPT_DIRTRIM`        | 用来定义当启用了 `\w` 或 `\W` 提示符字符串转义时显示的尾部目录名的数量。被删除的目录名会用一组英文句点替换 |
| `PS3`                   | `select` 命令的提示符                                        |
| `PS4`                   | 如果使用了bash的 `-x` 选项，在命令行之前显示的提示信息       |
| `PWD`                   | 当前工作目录                                                 |
| `RANDOM`                | 返回一个0～32767的随机数（对其的赋值可作为随机数生成器的种子） |
| `READLINE_LINE`         | 当使用 `bind -x` 命令时，存储Readline缓冲区的内容            |
| `READLINE_POINT`        | 当使用 `bind -x` 命令时，表示Readline缓冲区内容插入点的当前位置 |
| `REPLY`                 | read命令的默认变量                                           |
| `SECONDS`               | 自从shell启动到现在的秒数（对其赋值将会重置计数器）          |
| `SHELL`                 | bash shell的全路径名                                         |
| `SHELLOPTS`             | 已启用bash shell选项列表，列表项之间以冒号分隔               |
| `SHLVL`                 | shell的层级；每次启动一个新bash shell，该值增加1             |
| `TIMEFORMAT`            | 指定了shell的时间显示格式                                    |
| `TMOUT`                 | `select` 和 `read` 命令在没输入的情况下等待多久（以秒为单位）。默认值为0，表示无限长 |
| `TMPDIR`                | 目录名，保存bash shell创建的临时文件                         |
| `UID`                   | 当前用户的真实用户ID（数字形式）                             |

### 6.4  设置PATH环境变量

当你在shell命令行界面中输入一个外部命令时，shell必须搜索系统来找到对应的程序。`PATH` 环境变量定义了用于进行命令和程序查找的目录。

```
$ PATH=$PATH:.
```

### 6.5  定位系统环境变量

在你登入Linux系统启动一个bash shell时，默认情况下bash会在几个文件中查找命令。这些文件叫作**启动文件** 或**环境文件** 。

当你登录Linux系统时，bash shell会作为登录shell启动。登录shell会从5个不同的启动文件里读取命令：

- /etc/profile
- $HOME/.bash_profile
- $HOME/.bashrc
- $HOME/.bash_login
- $HOME/.profile

<b>/etc/profile</b>

/etc/profile文件是bash shell默认的的主启动文件。只要你登录了Linux系统，bash就会执行/etc/profile启动文件中的命令。

<b>$HOME目录下的启动文件</b>

剩下的启动文件都起着同一个作用：提供一个用户专属的启动文件来定义该用户所用到的环境变量。大多数Linux发行版只用这四个启动文件中的一到两个：

- $HOME/.bash_profile
- $HOME/.bashrc
- $HOME/.bash_login
- $HOME/.profile

.bash_profile启动文件会先去检查HOME目录中是不是还有一个叫.bashrc的启动文件。如果有的话，会先执行启动文件里面的命令。

#### **交互式shell**

如果你的bash shell不是登录系统时启动的（比如是在命令行提示符下敲入`bash` 时启动），那么你启动的shell叫作**交互式shell** 。如果bash是作为交互式shell启动的，它就不会访问/etc/profile文件，只会检查用户HOME目录中的.bashrc文件。

#### **非交互式shell**

系统执行shell脚本时用的就是这种shell。不同的地方在于它没有命令行提示符。但是当你在系统上运行脚本时，也许希望能够运行一些特定启动的命令。为了处理这种情况，bash shell提供了`BASH_ENV` 环境变量。当shell启动一个非交互式shell进程时，它会检查这个环境变量来查看要执行的启动文件。如果有指定的文件，shell会执行该文件里的命令，这通常包括shell脚本变量设置。

#### 环境变量持久化

对全局环境变量来说（Linux系统中所有用户都需要使用的变量），可能更倾向于将新的或修改过的变量设置放在/etc/profile文件中，但这可不是什么好主意。如果你升级了所用的发行版，这个文件也会跟着更新，那你所有定制过的变量设置可就都没有了。

最好是在/etc/profile.d目录中创建一个以.sh结尾的文件。把所有新的或修改过的全局环境变量设置放在这个文件中。

在大多数发行版中，存储个人用户永久性bash shell变量的地方是$HOME/.bashrc文件。这一点适用于所有类型的shell进程。但如果设置了`BASH_ENV` 变量，那么记住，除非它指向的是$HOME/.bashrc，否则你应该将非交互式shell的用户变量放在别的地方。

### 6.6  数组变量

环境变量有一个很酷的特性就是，它们可作为**数组** 使用。数组是能够存储多个值的变量。这些值可以单独引用，也可以作为整个数组来引用。

要给某个环境变量设置多个值，可以把值放在括号里，值与值之间用空格分隔。

```
$ mytest=(one two three four five)
```

要引用一个单独的数组元素，就必须用代表它在数组中位置的数值索引值。索引值要用方括号括起来。否则只显示数组第一个值。

```
$ echo ${mytest[2]}
```

要显示整个数组变量，可用星号作为通配符放在索引值的位置。

```
$ echo ${mytest[*]}
```

改变某个索引位置的值

```
$ mytest[2]=seven
```

删除数组中某个位置的值

```
$ unset mytest[2]
```

## 7. Linux权限

### 7.1  Linux的安全性

用户权限是通过创建用户时分配的**用户ID** （User ID，通常缩写为UID）来跟踪的。UID是数值，每个用户都有唯一的UID，但在登录系统时用的不是UID，而是**登录名** 。

Linux系统会为各种各样的功能创建不同的用户账户，而这些账户并不是真的用户。这些账户叫作**系统账户** ，是系统上运行的各种服务进程访问资源用的特殊账户。所有运行在后台的服务都需要用一个系统用户账户登录到Linux系统上。

在安全成为一个大问题之前，这些服务经常会用root账户登录。遗憾的是，如果有非授权的用户攻陷了这些服务中的一个，他立刻就能作为root用户进入系统。为了防止发生这种情况，现在运行在Linux服务器后台的几乎所有的服务都是用自己的账户登录。这样的话，即使有人攻入了某个服务，也无法访问整个系统。

<b>/etc/passwd文件</b>

```
$ cat /etc/passwd
```

字段包含了如下信息：

- 登录用户名
- 用户密码
- 用户账户的UID（数字形式）
- 用户账户的组ID（GID）（数字形式）
- 用户账户的文本描述（称为备注字段）
- 用户HOME目录的位置
- 用户的默认shell

<b>/etc/shadow文件</b>

/etc/shadow文件对Linux系统密码管理提供了更多的控制。只有root用户才能访问/etc/shadow文件，这让它比起/etc/passwd安全许多。/etc/shadow文件为系统上的每个用户账户都保存了一条记录。

```
# cat /etc/shadow
```

在/etc/shadow文件的每条记录中都有9个字段：

- 与/etc/passwd文件中的登录名字段对应的登录名
- 加密后的密码
- 自上次修改密码后过去的天数密码（自1970年1月1日开始计算）
- 多少天后才能更改密码
- 多少天后必须更改密码
- 密码过期前提前多少天提醒用户更改密码
- 密码过期后多少天禁用用户账户
- 用户账户被禁用的日期（用自1970年1月1日到当天的天数表示）
- 预留字段给将来使用

<b>添加新用户(useradd)</b>

Linux系统添加新用户的主要工具是`useradd` 。这个命令简单快捷，可以一次性创建新用户账户及设置用户HOME目录结构。`useradd` 命令使用系统的默认值以及命令行参数来设置用户账户。系统默认值被设置在/etc/default/useradd文件中。

`-D` 选项的`useradd` 命令查看所用Linux系统中的这些默认值

```
# /usr/sbin/useradd -D
```

这个例子列出的默认值如下：

- 新用户会被添加到GID为`100` 的公共组；(GROUP=100)
- 新用户的HOME目录将会位于/home/loginname；(HOME=/home)
- 新用户账户密码在过期后不会被禁用；(INACTIVE=-1)
- 新用户账户未被设置过期日期；(EXPIRE=)
- 新用户账户将bash shell作为默认shell；(SHELL=/bin/bash)
- 系统会将/etc/skel目录下的内容复制到用户的HOME目录下；(SKEL=/etc/skel)
- 系统为该用户账户在mail目录下创建一个用于接收邮件的文件。(CREATE_MAIL_SPOOL=yes)

 `useradd` 命令行参数:

| **参数**               | **描述**                                                     |
| :--------------------- | :----------------------------------------------------------- |
| `-c` `*comment*`       | 给新用户添加备注                                             |
| `-d` `*home_dir*`      | 为主目录指定一个名字（如果不想用登录名作为主目录名的话）     |
| `-e` `*expire_date*`   | 用YYYY-MM-DD格式指定一个账户过期的日期                       |
| `-f` `*inactive_days*` | 指定这个账户密码过期后多少天这个账户被禁用； `0` 表示密码一过期就立即禁用， `1` 表示禁用这个功能 |
| `-g` `*initial_group*` | 指定用户登录组的GID或组名                                    |
| `-G` `*group* ``...`   | 指定用户除登录组之外所属的一个或多个附加组                   |
| `-k`                   | 必须和 `-m` 一起使用，将/etc/skel目录的内容复制到用户的HOME目录 |
| `-m`                   | 创建用户的HOME目录                                           |
| `-M`                   | 不创建用户的HOME目录（当默认设置里要求创建时才使用这个选项） |
| `-n`                   | 创建一个与用户登录名同名的新组                               |
| `-r`                   | 创建系统账户                                                 |
| `-p` `*passwd*`        | 为用户账户指定默认密码                                       |
| `-s` `*shell*`         | 指定默认的登录shell                                          |
| `-u` `*uid*`           | 为账户指定唯一的UID                                          |

`useradd `更改默认值的参数:

| **参数**                 | **描述**                                     |
| :----------------------- | :------------------------------------------- |
| `-b` `*default_home*`    | 更改默认的创建用户HOME目录的位置             |
| `-e` `*expiration_date*` | 更改默认的新账户的过期日期                   |
| `-f` `*inactive*`        | 更改默认的新用户从密码过期到账户被禁用的天数 |
| `-g` `*group*`           | 更改默认的组名称或GID                        |
| `-s` `*shell*`           | 更改默认的登录shell                          |

<b>删除账户(userdel)</b>

`userdel` 命令会只删除/etc/passwd文件中的用户信息，而不会删除系统中属于该账户的任何文件。

```
# /usr/sbin/userdel test
```

`-r` 参数，`userdel` 会删除用户的HOME目录以及邮件目录。然而，系统上仍可能存有已删除用户的其他文件。这在有些环境中会造成问题。

```
# /usr/sbin/userdel -r test
```

<b>修改账户</b>

Linux提供了一些不同的工具来修改已有用户账户的信息。

| **命令**   | **描述**                                                 |
| :--------- | :------------------------------------------------------- |
| `usermod`  | 修改用户账户的字段，还可以指定主要组以及附加组的所属关系 |
| `passwd`   | 修改已有用户的密码                                       |
| `chpasswd` | 从文件中读取登录名密码对，并更新密码                     |
| `chage`    | 修改密码的过期日期                                       |
| `chfn`     | 修改用户账户的备注信息                                   |
| `chsh`     | 修改用户账户的默认登录shell                              |

<b>usermod</b>

`usermod` 命令是用户账户修改工具中最强大的一个。它能用来修改/etc/passwd文件中的大部分字段，只需用与想修改的字段对应的命令行参数就可以了。

选项:

- `-l` 修改用户账户的登录名。
- `-L` 锁定账户，使用户无法登录。
- `-p` 修改账户的密码。
- `-U` 解除锁定，使用户能够登录。

`-L` 选项尤其实用。它可以将账户锁定，使用户无法登录，同时无需删除账户和用户的数据。要让账户恢复正常，只要用`-U` 选项就行了。

<b> `passwd `**和** `chpasswd` </b>

修改密码

```
# passwd test
```

批量修改密码

```
# chpasswd < users.txt
```

<b>`chsh`、 `chfn `和 `chage` </b>

`chsh` 、`chfn` 和`chage` 工具专门用来修改特定的账户信息。

`chsh` 命令用来快速修改默认的用户登录

```
#  chsh -s /bin/csh test
```

在使用`chfn` 命令时没有参数，它会向你询问要将哪些适合的内容加进备注字段

```
# chfn test
```

`chage` 命令用来帮助管理用户账户的有效期

| **参数** | **描述**                           |
| :------- | :--------------------------------- |
| `-d`     | 设置上次修改密码到现在的天数       |
| `-E`     | 设置密码过期的日期                 |
| `-I`     | 设置密码过期到锁定账户的天数       |
| `-m`     | 设置修改密码之间最少要多少天       |
| `-W`     | 设置密码过期前多久开始出现提醒信息 |

### 7.2  Linux组

每个组都有唯一的GID——跟UID类似，在系统上这是个唯一的数值。除了GID，每个组还有唯一的组名。Linux系统上有一些组工具可以创建和管理你自己的组。

<b>/etc/group文件</b>

与用户账户类似，组信息也保存在系统的一个文件中。/etc/group文件包含系统上用到的每个组的信息。

> 当一个用户在/etc/passwd文件中指定某个组作为默认组时，用户账户不会作为该组成员再出现在/etc/group文件中。

/etc/group文件有4个字段：

- 组名
- 组密码
- GID
- 属于该组的用户列表

<b>创建新组(groupadd)</b>

```
# /usr/sbin/groupadd shared
```

将test账户添加到shared组中

```
# /usr/sbin/usermod -G shared test
```

<b>修改组(groupmod)</b>

`groupmod` 命令可以修改已有组的GID（加`-g` 选项）或组名（加`-n` 选项）

```
# /usr/sbin/groupmod -n sharing shared
```

### 7.3  文件权限

<b>文件权限符号</b>

```
$ ls -l
total 68
-rw-rw-r-- 1 rich rich   50 2010-09-13 07:49 file1.gz
-rw-rw-r-- 1 rich rich   23 2010-09-13 07:50 file2
```

输出结果的第一个字段就是描述文件和目录权限的编码。这个字段的第一个字符代表了对象的类型：

- `-` 代表文件
- `d` 代表目录
- `l` 代表链接
- `c` 代表字符型设备
- `b` 代表块设备
- `n` 代表网络设备

之后有3组三字符的编码。每一组定义了3种访问权限：

- `r` 代表对象是可读的
- `w` 代表对象是可写的
- `x` 代表对象是可执行的

若没有某种权限，在该权限位会出现单破折线。这3组权限分别对应对象的3个安全级别：

- 对象的属主
- 对象的属组
- 系统其他用户

<b>默认文件权限</b>

`umask` 命令用来设置所创建文件和目录的默认权限。

```
$ umask
```

权限码

| **权限** | **二进制值** | **八进制值** | **描述**         |
| :------- | :----------- | :----------- | :--------------- |
| `---`    | `000`        | `0`          | 没有任何权限     |
| `--x`    | `001`        | `1`          | 只有执行权限     |
| `-w-`    | `010`        | `2`          | 只有写入权限     |
| `-wx`    | `011`        | `3`          | 有写入和执行权限 |
| `r--`    | `100`        | `4`          | 只有读取权限     |
| `r-x`    | `101`        | `5`          | 有读取和执行权限 |
| `rw-`    | `110`        | `6`          | 有读取和写入权限 |
| `rwx`    | `111`        | `7`          | 有全部权限       |

<b>改变权限</b>

```
# chmod options mode file
```

`mode` 参数可以使用八进制模式或符号模式进行安全性设置。八进制模式设置非常直观，直接用期望赋予文件的标准3位八进制权限码即可。

符号模式

```
[ugoa…][[+-=][rwxXstugo…]
```

权限作用的对象：

- `u` 代表用户
- `g` 代表组
- `o` 代表其他
- `a` 代表上述所有

额外的设置有以下几项:

- `X` ：如果对象是目录或者它已有执行权限，赋予执行权限。
- `s` ：运行时重新设置UID或GID。
- `t` ：保留文件或目录。
- `u` ：将权限设置为跟属主一样。
- `g` ：将权限设置为跟属组一样。
- `o` ：将权限设置为跟其他用户一样。

```
$ chmod o+r newfile
```

<b>改变所属关系</b>

改变文件的属主，Linux提供了两个命令来实现这个功能：`chown` 命令用来改变文件的属主，`chgrp` 命令用来改变文件的默认属组。

```
chown options owner[.group] file
```

指定文件的新属主

```
# chown dan newfile
```

改变文件的属主和属组

```
# chown dan.shared newfile
```

`chgrp` 命令可以更改文件或目录的默认属组

```
$ chgrp shared newfile
```

### 7.4  共享文件

Linux还为每个文件和目录存储了3个额外的信息位。

- **设置用户ID（SUID）** ：当文件被用户使用时，程序会以文件属主的权限运行。
- **设置组ID（SGID）** ：对文件来说，程序会以文件属组的权限运行；对目录来说，目录中创建的新文件会以目录的默认属组作为默认属组。
- **粘着位** ：进程结束后文件还驻留（粘着）在内存中。

SGID位对文件共享非常重要。启用SGID位后，你可以强制在一个共享目录下创建的新文件都属于该目录的属组，这个组也就成为了每个用户的属组。

SGID可通过`chmod` 命令设置。它会加到标准3位八进制值之前（组成4位八进制值），或者在符号模式下用符号`s` 。

**chmod SUID、SGID和粘着位的八进制值**

| **二进制值** | **八进制值** | **描述**             |
| :----------- | :----------- | :------------------- |
| `000`        | `0`          | 所有位都清零         |
| `001`        | `1`          | 粘着位置位           |
| `010`        | `2`          | SGID位置位           |
| `011`        | `3`          | SGID位和粘着位都置位 |
| `100`        | `4`          | SUID位置位           |
| `101`        | `5`          | SUID位和粘着位都置位 |
| `110`        | `6`          | SUID位和SGID位都置位 |
| `111`        | `7`          | 所有位都置位         |

<b>设置共享目录</b>

创建一个共享目录

```
$ mkdir testdir
```

创建一个共享组

```
$ groupadd shared
```

改变共享目录所属组为共享组

```
$ chgrp shared testdir
```

将目录的SGID位置位，以保证目录中新建文件都用shared作为默认属组

```
$ chmod g+s testdir
```

所有组成员都需把他们的`umask` 值设置成文件对属组成员可写

```
$ umask 002
```

## 8. 管理文件系统

### 8.1  基本的Linux文件系统

####  **ext文件系统**

Linux操作系统中引入的最早的文件系统叫作**扩展文件系统** （extended filesystem，简记为ext）。它为Linux提供了一个基本的类Unix文件系统：使用虚拟目录来操作硬件设备，在物理设备上按定长的块来存储数据。

ext文件系统采用名为**索引节点** 的系统来存放虚拟目录中所存储文件的信息。索引节点系统在每个物理设备中创建一个单独的表（称为**索引节点表** ）来存储这些文件的信息。存储在虚拟目录中的每一个文件在索引节点表中都有一个条目。ext文件系统名称中的extended部分来自其跟踪的每个文件的额外数据，包括：

- 文件名
- 文件大小
- 文件的属主
- 文件的属组
- 文件的访问权限
- 指向存有文件数据的每个硬盘块的指针

#### **ext2文件系统**

ext文件系统有不少限制，比如文件大小不得超过2 GB。在Linux出现后不久，ext文件系统就升级到了第二代扩展文件系统，叫作ext2。

ext2文件系统是ext文件系统基本功能的一个扩展，但保持了同样的结构。ext2文件系统扩展了索引节点表的格式来保存系统上每个文件的更多信息。

ext2的索引节点表为文件添加了创建时间值、修改时间值和最后访问时间值来帮助系统管理员追踪文件的访问情况。ext2文件系统还将允许的最大文件大小增加到了2 TB（在ext2的后期版本中增加到了32 TB），以容纳数据库服务器中常见的大文件。

ext2文件系统还改变了文件在数据块中存储的方式。ext文件系统常见的问题是在文件写入到物理设备时，存储数据用的块很容易分散在整个设备中（称作**碎片化** ，fragmentation）。数据块的碎片化会降低文件系统的性能，因为需要更长的时间在存储设备中查找特定文件的所有块。保存文件时，ext2文件系统通过按组分配磁盘块来减轻碎片化。通过将数据块分组，文件系统在读取文件时不需要为了数据块查找整个物理设备。

#### **日志文件系统**

**日志文件系统** 为Linux系统增加了一层安全性。它不再使用之前先将数据直接写入存储设备再更新索引节点表的做法，而是先将文件的更改写入到临时文件（称作**日志** ，journal）中。在数据成功写到存储设备和索引节点表之后，再删除对应的日志条目。

如果系统在数据被写入存储设备之前崩溃或断电了，日志文件系统下次会读取日志文件并处理上次留下的未写入的数据。

**文件系统日志方法**

| **方法** | **描述**                                                     |
| :------- | :----------------------------------------------------------- |
| 数据模式 | 索引节点和文件都会被写入日志；丢失数据风险低，但性能差       |
| 有序模式 | 只有索引节点数据会被写入日志，但只有数据成功写入后才删除；在性能和安全性之间取得了良好的折中 |
| 回写模式 | 只有索引节点数据会被写入日志，但不控制文件数据何时写入；丢失数据风险高，但仍比不用日志好 |

数据模式日志方法是目前为止最安全的数据保护方法，但同时也是最慢的。所有写到存储设备上的数据都必须写两次：第一次写入日志，第二次写入真正的存储设备。这样会导致性能很差，尤其是对要做大量数据写入的系统而言。

####  **ext3文件系统**

2001年，ext3文件系统被引入Linux内核中，直到最近都是几乎所有Linux发行版默认的文件系统。它采用和ext2文件系统相同的索引节点表结构，但给每个存储设备增加了一个日志文件，以将准备写入存储设备的数据先记入日志。

默认情况下，ext3文件系统用有序模式的日志功能——只将索引节点信息写入日志文件，直到数据块都被成功写入存储设备才删除。你可以在创建文件系统时用简单的一个命令行选项将ext3文件系统的日志方法改成数据模式或回写模式。

虽然ext3文件系统为Linux文件系统添加了基本的日志功能，但它仍然缺少一些功能。例如ext3文件系统无法恢复误删的文件，它没有任何内建的数据压缩功能（虽然有个需单独安装的补丁支持这个功能），ext3文件系统也不支持加密文件。鉴于这些原因，Linux项目的开发人员选择再接再厉，继续改进ext3文件系统。

#### **ext4文件系统**

ext4文件系统在2008年受到Linux内核官方支持，现在已是大多数流行的Linux发行版采用的默认文件系统，比如Ubuntu。

除了支持数据压缩和加密，ext4文件系统还支持一个称作**区段** （extent）的特性。区段在存储设备上按块分配空间，但在索引节点表中只保存起始块的位置。由于无需列出所有用来存储文件中数据的数据块，它可以在索引节点表中节省一些空间。

ext4还引入了**块预分配技术** （block preallocation）。如果你想在存储设备上给一个你知道要变大的文件预留空间，ext4文件系统可以为文件分配所有需要用到的块，而不仅仅是那些现在已经用到的块。ext4文件系统用`0` 填满预留的数据块，不会将它们分配给其他文件。

####  **Reiser文件系统**

2001年，Hans Reiser为Linux创建了第一个称为ReiserFS的日志文件系统。ReiserFS文件系统只支持回写日志模式——只把索引节点表数据写到日志文件。ReiserFS文件系统也因此成为Linux上最快的日志文件系统之一。

有两个有意思的特性被引入了ReiserFS文件系统：一个是你可以在线调整已有文件系统的大小；另一个是被称作**尾部压缩** （tailpacking）的技术，该技术能将一个文件的数据填进另一个文件的数据块中的空白空间。如果你必须为已有文件系统扩容来容纳更多的数据，在线调整文件系统大小功能非常好用。

#### **JFS文件系统**

作为可能依然在用的最老的日志文件系统之一，JFS（Journaled File System，**日志化文件系统** **1** ）是IBM在1990年为其Unix衍生版AIX开发的。然而直到第2版，它才被移植到Linux环境中。

> **1** 此处“日志化文件系统”是指Journaled File System这一Journal File System概念的具体实现。为防止读者混淆，后文中都将用JFS缩写代替。

#### **XFS文件系统**

XFS日志文件系统是另一种最初用于商业Unix系统而如今走进Linux世界的文件系统。美国硅图公司（SGI）最初在1994年为其商业化的IRIX Unix系统开发了XFS。2002年，它被发布到了适用于Linux环境的版本。

XFS文件系统采用回写模式的日志，在提供了高性能的同时也引入了一定的风险，因为实际数据并未存进日志文件。XFS文件系统还允许在线调整文件系统的大小，这点类似于ReiserFS文件系统，除了XFS文件系统只能扩大不能缩小。

#### **写时复制文件系统**

采用了日志式技术，你就必须在安全性和性能之间做出选择。尽管数据模式日志提供了最高的安全性，但是会对性能带来影响，因为索引节点和数据都需要被日志化。如果是回写模式日志，性能倒是可以接受，但安全性就会受到损害。

就文件系统而言，日志式的另一种选择是一种叫作**写时复制** （copy-on-write，COW）的技术。COW利用快照兼顾了安全性和性能。如果要修改数据，会使用克隆或可写快照。修改过的数据并不会直接覆盖当前数据，而是被放入文件系统中的另一个位置上。即便是数据修改已经完成，之前的旧数据也不会被重写。

COW文件系统已日渐流行，接下来会简要概览其中最流行的两种（Btrf和ZFS）。

### 8.2  操作文件系统

#### 创建分区

必须在存储设备上创建分区来容纳文件系统。分区可以是整个硬盘，也可以是部分硬盘，以容纳虚拟目录的一部分。

<b>fdisk</b>

`fdisk` 工具用来帮助管理安装在系统上的任何存储设备上的分区。它是个交互式程序，允许你输入命令来逐步完成硬盘分区操作。

```
# fdisk /dev/sdb
```

<b>`fdisk` 命令</b>

| **命令** | **描述**                         |
| :------- | :------------------------------- |
| `a`      | 设置活动分区标志                 |
| `b`      | 编辑BSD Unix系统用的磁盘标签     |
| `c`      | 设置DOS兼容标志                  |
| `d`      | 删除分区                         |
| `l`      | 显示可用的分区类型               |
| `m`      | 显示命令选项                     |
| `n`      | 添加一个新分区                   |
| `o`      | 创建DOS分区表                    |
| `p`      | 显示当前分区表                   |
| `q`      | 退出，不保存更改                 |
| `s`      | 为Sun Unix系统创建一个新磁盘标签 |
| `t`      | 修改分区的系统ID                 |
| `u`      | 改变使用的存储单位               |
| `v`      | 验证分区表                       |
| `w`      | 将分区表写入磁盘                 |
| `x`      | 高级功能                         |

#### 创建文件系统

在将数据存储到分区之前，你必须用某种文件系统对其进行格式化，这样Linux才能使用它。每种文件系统类型都用自己的命令行程序来格式化分区。

<b>创建文件命令</b>

| **工具**     | **用途**                 |
| :----------- | :----------------------- |
| `mkefs`      | 创建一个ext文件系统      |
| `mke2fs`     | 创建一个ext2文件系统     |
| `mkfs.ext3`  | 创建一个ext3文件系统     |
| `mkfs.ext4`  | 创建一个ext4文件系统     |
| `mkreiserfs` | 创建一个ReiserFS文件系统 |
| `jfs_mkfs`   | 创建一个JFS文件系统      |
| `mkfs.xfs`   | 创建一个XFS文件系统      |
| `mkfs.zfs`   | 创建一个ZFS文件系统      |
| `mkfs.btrfs` | 创建一个Btrfs文件系统    |

并非所有文件系统工具都已经默认安装了。要想知道某个文件系统工具是否可用，可以使用`type` 命令。

```
$ type mkfs.ext4
```

创建一个默认的文件系统

```
$ sudo mkfs.ext4 /dev/sdb1
```

#### 文件系统的检查与恢复

就算是现代文件系统，碰上突然断电或者某个不规矩的程序在访问文件时锁定了系统，也会出现错误。幸而有一些命令行工具可以帮你将文件系统恢复正常。

`fsck` 命令能够检查和修复大部分类型的Linux文件系统，包括本章早些时候讨论过的ext、ext2、ext3、ext4、ReiserFS、JFS和XFS。该命令的格式是：

```
# fsck options filesystem
```

`fsck` 命令使用/etc/fstab文件来自动决定正常挂载到系统上的存储设备的文件系统。如果存储设备尚未挂载（比如你刚刚在新的存储设备上创建了个文件系统），你需要用`-t` 命令行选项来指定文件系统类型。

fsck命令选项：

| **选项** | **描述**                                                   |
| :------- | :--------------------------------------------------------- |
| `-a`     | 如果检测到错误，自动修复文件系统                           |
| `-A`     | 检查/etc/fstab文件中列出的所有文件系统                     |
| `-C`     | 给支持进度条功能的文件系统显示一个进度条（只有ext2和ext3） |
| `-N`     | 不进行检查，只显示哪些检查会执行                           |
| `-r`     | 出现错误时提示                                             |
| `-R`     | 使用 `-A` 选项时跳过根文件系统                             |
| `-s`     | 检查多个文件系统时，依次进行检查                           |
| `-t`     | 指定要检查的文件系统类型                                   |
| `-T`     | 启动时不显示头部信息                                       |
| `-V`     | 在检查时产生详细输出                                       |
| `-y`     | 检测到错误时自动修复文件系统                               |

### 8.3  逻辑卷管理

Linux**逻辑卷管理器** （logical volume manager，LVM）软件包正好可以用来做这个。它可以让你在无需重建整个文件系统的情况下，轻松地管理磁盘空间。

#### 逻辑卷管理布局

逻辑卷管理的核心在于如何处理安装在系统上的硬盘分区。在逻辑卷管理的世界里，硬盘称作**物理卷** （physical volume，PV）。每个物理卷都会映射到硬盘上特定的物理分区。

多个物理卷集中在一起可以形成一个**卷组** （volume group，VG）。逻辑卷管理系统将卷组视为一个物理硬盘，但事实上卷组可能是由分布在多个物理硬盘上的多个物理分区组成的。卷组提供了一个创建逻辑分区的平台，而这些逻辑分区则包含了文件系统。

整个结构中的最后一层是**逻辑卷** （logical volume，LV）。逻辑卷为Linux提供了创建文件系统的分区环境，作用类似于到目前为止我们一直在探讨的Linux中的物理硬盘分区。Linux系统将逻辑卷视为物理分区。

#### **Linux中的LVM**

Linux LVM是由Heinz Mauelshagen开发的，于1998年发布到了Linux社区。它允许你在Linux上用简单的命令行命令管理一个完整的逻辑卷管理环境。

Linux LVM有两个可用的版本。

- **LVM1** ：最初的LVM包于1998年发布，只能用于Linux内核2.4版本。它仅提供了基本的逻辑卷管理功能。
- **LVM2** ：LVM的更新版本，可用于Linux内核2.6版本。它在标准的LVM1功能外提供了额外的功能。

大部分采用2.6或更高内核版本的现代Linux发行版都提供对LVM2的支持。

<b>使用Linux LVM</b>

- 定义物理卷

创建过程的第一步就是将硬盘上的物理分区转换成Linux LVM使用的物理卷区段。`fdisk` 命令可以创建了基本的Linux分区之后通过`t` 命令改变分区类型。

```
# fdisk /dev/sdb
Command (m for help): t

Selected partition 1

Hex code (type L to list codes): 8e

Changed system type of partition 1 to 8e (Linux LVM)


Command (m for help): p
```

分区类型`8e` 表示这个分区将会被用作Linux LVM系统的一部分，而不是一个直接的文件系统（就像你在前面看到的`83` 类型的分区）。

- 用分区来创建实际的物理卷

`pvcreate` 定义了用于物理卷的物理分区。它只是简单地将分区标记成Linux LVM系统中的分区而已。

```
$ sudo pvcreate /dev/sdb1
  dev_is_mpath: failed to get device for 8:17

  Physical volume "/dev/sdb1" successfully created
```

别被吓人的消息`dev_is_mpath: failed to get device for 8:17` 或类似的消息唬住了。只要看到了`successfully created` 就没问题。`pvcreate` 命令会检查分区是否为多路（multi-path，mpath）设备。如果不是的话，就会发出上面那段消息。

- 显示已创建的物理卷

使用`pvdisplay` 命令来显示已创建的物理卷列表。

```
$ sudo pvdisplay /dev/sdb1
```

- 创建卷组

从物理卷中创建一个或多个卷组。究竟要为系统创建多少卷组并没有既定的规则，你可以将所有的可用物理卷加到一个卷组，也可以结合不同的物理卷创建多个卷组。使用`vgcreate` 命令。

```
$ sudo vgcreate Vol1 /dev/sdb1
  Volume group "Vol1" successfully created
```

`vgdisplay` 命令查看新创建的卷组的细节

```
$ sudo vgdisplay Vol1
```

- 创建逻辑卷

Linux系统使用逻辑卷来模拟物理分区，并在其中保存文件系统。Linux系统会像处理物理分区一样处理逻辑卷，允许你定义逻辑卷中的文件系统，然后将文件系统挂载到虚拟目录上。要创建逻辑卷，使用`lvcreate` 命令。

`lvcreate` 选项

| **选项** | **长选项名**   | **描述**                                                   |
| :------- | :------------- | :--------------------------------------------------------- |
| `-c`     | `--chunksize`  | 指定快照逻辑卷的单位大小                                   |
| `-C`     | `--contiguous` | 设置或重置连续分配策略                                     |
| `-i`     | `--stripes`    | 指定条带数                                                 |
| `-I`     | `--stripesize` | 指定每个条带的大小                                         |
| `-l`     | `--extents`    | 指定分配给新逻辑卷的逻辑区段数，或者要用的逻辑区段的百分比 |
| `-L`     | `--size`       | 指定分配给新逻辑卷的硬盘大小                               |
|          | `--minor`      | 指定设备的次设备号                                         |
| `-m`     | `--mirrors`    | 创建逻辑卷镜像                                             |
| `-M`     | `--persistent` | 让次设备号一直有效                                         |
| `-n`     | `--name`       | 指定新逻辑卷的名称                                         |
| `-p`     | `--permission` | 为逻辑卷设置读/写权限                                      |
| `-r`     | `--readahead`  | 设置预读扇区数                                             |
| `-R`     | `--regionsize` | 指定将镜像分成多大的区                                     |
| `-s`     | `snapshot`     | 创建快照逻辑卷                                             |
| `-Z`     | `--zero`       | 将新逻辑卷的前1 KB数据设置为零                             |

```
$ sudo lvcreate -l 100%FREE -n lvtest Vol1
```

如果想查看你创建的逻辑卷的详细情况，可用`lvdisplay` 命令。

```
$ sudo lvdisplay Vol1

  --- Logical volume ---

  LV Path                /dev/Vol1/lvtest

  LV Name                lvtest

  VG Name                Vol1

  LV UUID                4W2369-pLXy-jWmb-lIFN-SMNX-xZnN-3KN208
```

- 创建文件系统

运行完`lvcreate` 命令之后，逻辑卷就已经产生了，但它还没有文件系统。你必须使用相应的命令行程序来创建所需要的文件系统。

```
$ sudo mkfs.ext4 /dev/Vol1/lvtest
```

- 挂载

在创建了新的文件系统之后，可以用标准Linux `mount` 命令将这个卷挂载到虚拟目录中，就跟它是物理分区一样。唯一的不同是你需要用特殊的路径来标识逻辑卷。

```
$ sudo mount /dev/Vol1/lvtest /mnt/my_partition
```

## 9. 安装软件程序

Linux上能见到的各种**包管理系统** （package management system，PMS），以及用来进行软件安装、管理和删除的命令行工具。

### 9.1  包管理基础

PMS工具及相关命令在不同的Linux发行版上有很大的不同。Linux中广泛使用的两种主要的PMS基础工具是`dpkg` 和`rpm` 。

基于Debian的发行版（如Ubuntu和Linux Mint）使用的是`dpkg` 命令，这些发行版的PMS工具也是以该命令为基础的。`dpkg` 会直接和Linux系统上的PMS交互，用来安装、管理和删除软件包。

基于Red Hat的发行版（如Fedora、openSUSE及Mandriva）使用的是`rpm` 命令，该命令是其PMS的底层基础。

#### **基于Debian的系统**

`dpkg` 命令是基于Debian系PMS工具的核心。包含在这个PMS中的其他工具有：

- `apt-get`
- `apt-cache`
- `aptitude`

<b>aptitude</b>

aptitude工具本质上是apt工具和`dpkg` 的前端。`dpkg` 是软件包管理系统工具，而aptitude则是完整的软件包管理系统。`aptitude` 默认的软件仓库位置是在安装Linux发行版时设置的。具体位置存储在文件`/etc/apt/sources.list` 中

显示某个特定包的详细信息:

```
$ aptitude show package_name
```

搜索：

```
$ aptitude search package_name
```

安装：

```
$ aptitude install package_name
```

更新软件仓库

```
$ sudo aptitude safe-upgrade
```

卸载：

```
$ sudo aptitude purge package_name
```

<b>dpkg</b>

无法通过`aptitude` 看到的一个细节是所有跟某个特定软件包相关的所有文件的列表:

```
$ dpkg -L package_name
```

同样可以进行反向操作，查找某个特定文件属于哪个软件包:

> 注意，在使用的时候必须用绝对文件路径。

```
$ dpkg --search absolute_file_name
```

#### **基于Red Hat的系统**

和基于Debian的发行版类似，基于Red Hat的系统也有几种不同的可用前端工具。常见的有以下3种。

- `yum` ：在Red Hat和Fedora中使用。
- `urpm` ：在Mandriva中使用。
- `zypper` ：在openSUSE中使用。

<b>yum</b>

找出系统上已安装的包:

```
# yum list installed
```

找出某个特定软件包的详细信息:

```
# yum list package_name
```

找出系统上的某个特定文件属于哪个软件包

```
# yum provides file_name
```

查找配置文件/etc/yum.conf归属的例子:

```
# yum provides /etc/yum.conf
```

安装：

```
# yum install package_name
```

下载`rpm` 安装文件并用`yum` 安装:

```
# yum localinstall package_name.rpm
```

要列出所有已安装包的可用更新：

```
# yum list updates
```

更新指定包：

```
# yum update package_name
```

对所有包进行更新：

```
# yum update
```

只删除软件包而保留配置文件和数据文件

```
# yum remove package_name
```

要删除软件和它所有的文件:

```
# yum erase package_name
```

处理坏的包依赖关系：

```
# yum clean all

查看包的依赖
# yum deplist package_name

最后一招
# yum update --skip-broken 
```

> `--skip-broken` 选项允许你忽略依赖关系损坏的那个包，继续去更新其他软件包。这可能救不了损坏的包，但至少可以更新系统上的其他包。

要想知道你现在正从哪些仓库中获取软件，输入如下命令：

```
yum repolist
```

#### 源码安装

以sysstat-11.1.1.tar.gz为例

- 解包

```
# tar -zxvf sysstat-11.1.1.tar.gz
```

- 进到源码目录

```
# cd sysstat-11.1.1
```

> 在这个目录的列表中，应该能看到README或AAAREADME文件。读这个文件非常重要。该文件中包含了软件安装所需要的操作。
>
> 按照README文件中的建议，下一步是为系统配置sysstat。它会检查你的Linux系统，确保它拥有合适的编译器能够编译源代码，另外还要具备正确的库依赖关系。

- 核查依赖关系

```
# ./configure
```

> 如果哪里有错了，在`configure` 步骤中会显示一条错误消息说明缺失了什么东西。如果你所用的Linux发行版中没有安装GNU C编译器，那只会得到一条错误信息。对于其他问题，你会看到好几条消息，说明安装了什么，没有安装什么。

- `make` 命令来构建各种二进制文件

`make` 命令会编译源码，然后链接器会为这个包创建最终的可执行文件。和`configure` 命令一样，`make` 命令会在编译和链接所有的源码文件的过程中产生大量的输出。

```
# make
```

- 安装

`make` 步骤结束时，可运行的sysstat软件程序就会出现在目录下！但是从那个目录下运行程序有些不便。你会想将它安装到Linux系统中常用的位置上。要这样的话，就必须以root用户身份登录（或者用`sudo` 命令，如果你的Linux发行版偏好这个的话），然后用`make` 命令的`install` 选项。

```
# make install
```

## 10. 编辑器

### 10.1  vim编辑器

vi编辑器是Unix系统最初的编辑器。它使用控制台图形模式来模拟文本编辑窗口，允许查看文件中的行、在文件中移动、插入、编辑和替换文本。

尽管它可能是世界上最复杂的编辑器（至少讨厌它的人是这么认为的），但其拥有的大量特性使其成为Unix管理员多年来的支柱性工具。

在GNU项目将vi编辑器移植到开源世界时，他们决定对其作一些改进。由于它不再是以前Unix中的那个原始的vi编辑器了，开发人员也就将它重命名为vi improved，或vim。

#### **检查vim软件包**

```
$ alias vi
```

> 在开始研究vim编辑器之前，最好先搞明白你所用的Linux系统是哪种vim软件包。在有些发行版中安装的是完整的vim，另外还有一个`vi` 命令的别名，就像下面所显示的CentOS发行版中的那样。

#### ubuntu下的安装

```
$ sudo apt-get install vim
```

> 当输入`vi` 命令时，执行的是程序`/usr/bin/vim.tiny` 。`vim.tiny` 只提供少量的vim编辑器功能。

#### vim基础

打开文件:

```
$ vim myprog.c
```

vim编辑器有两种操作模式：

- 普通模式
- 插入模式

当你刚打开要编辑的文件时（或新建一个文件时），vim编辑器会进入普通模式。在普通模式中，vim编辑器会将按键解释成命令.

在插入模式下，vim会将你在当前光标位置输入的每个键都插入到缓冲区。按下i键就可以进入插入模式。要退出插入模式回到普通模式，按下键盘上的退出键（ESC键，也就是Escape键）就可以了。

vim中有用来移动光标的命令:

- `h` ：左移一个字符。
- `j` ：下移一行（文本中的下一行）。
- `k` ：上移一行（文本中的上一行）。
- `l` ：右移一个字符。

在大的文本文件中一行一行地来回移动会特别麻烦，幸而vim提供了一些能够提高移动速度的命令。

- `PageDown` （或Ctrl+F）：下翻一屏。
- `PageUp` （或Ctrl+B）：上翻一屏。
- `G` ：移到缓冲区的最后一行。
- `num G` ：移动到缓冲区中的第 `num `行。
- `gg` ：移到缓冲区的第一行。

在命令行模式下有几个命令可以将缓冲区的数据保存到文件中并退出vim。

- `q` ：如果未修改缓冲区数据，退出。
- `q!` ：取消所有对缓冲区数据的修改并退出。
- `w` `*filename* `：将文件保存到另一个文件中。
- `wq` ：将缓冲区数据保存到文件中并退出。

<b>编辑命令</b>

| **命令**     | **描述**                                              |
| :----------- | :---------------------------------------------------- |
| `x`          | 删除当前光标所在位置的字符                            |
| `dd`         | 删除当前光标所在行                                    |
| `dw`         | 删除当前光标所在位置的单词                            |
| `d$`         | 删除当前光标所在位置至行尾的内容                      |
| `J`          | 删除当前光标所在行行尾的换行符（拼接行）              |
| `u`          | 撤销前一编辑命令                                      |
| `a`          | 在当前光标后追加数据                                  |
| `A`          | 在当前光标所在行行尾追加数据                          |
| `r` `*char*` | 用 `*char* `替换当前光标所在位置的单个字符            |
| `R` `*text*` | 用 `*text* `覆盖当前光标所在位置的数据，直到按下ESC键 |

<b>复制和粘贴</b>

vim中复制命令是`y` （代表yank）。可以在`y` 后面使用和`d` 命令相同的第二字符（`yw` 表示复制一个单词，`y$` 表示复制到行尾）。在复制文本后，把光标移动到你想放置文本的地方，输入`p` 命令。复制的文本就会出现在该位置。

<b>查找和替换</b>

要输入一个查找字符串，就按下斜线（/）键。光标会跑到消息行，然后vim会显示出斜线。在输入你要查找的文本后，按下回车键。vim编辑器会采用以下三种回应中的一种。

- 如果要查找的文本出现在光标当前位置之后，则光标会跳到该文本出现的第一个位置。
- 如果要查找的文本未在光标当前位置之后出现，则光标会绕过文件末尾，出现在该文本所在的第一个位置
- 要继续查找同一个单词，按下斜线键，然后按回车键。或者使用n键，表示下一个（next）。

替换命令允许你快速用另一个单词来替换文本中的某个单词。必须进入命令行模式才能使用替换命令。替换命令的格式是：

```
:s/old/new/
```

vim编辑器会跳到`old` 第一次出现的地方，并用`new` 来替换。可以对替换命令作一些修改来替换多处文本。

- `:s/old/new/g` ：一行命令替换所有`old` 。
- `:` `*n* ``,` `*ms* ``/old/new/g` ：替换行号`n` 和`m` 之间所有`old` 。
- `:%s/old/new/g` ：替换整个文件中的所有`old` 。
- `:%s/old/new/gc` ：替换整个文件中的所有`old` ，但在每次出现时提示。

## 11. 构建基础脚本

### 11.1  创建shell脚本

在创建shell脚本文件时，必须在文件的第一行指定要使用的shell。其格式为：

```
#!/bin/bash
```

> 在通常的shell脚本中，井号（`#` ）用作注释行。shell并不会处理shell脚本中的注释行。然而，shell脚本文件的第一行是个例外，`#` 后面的惊叹号会告诉shell用哪个shell来运行脚本。

编辑test脚本内容：

```
#!/bin/bash

date

who
```

执行：

```
# test
bash: test1: command not found
```

> 你要跨过的第一个障碍是让bash shell能找到你的脚本文件。如第6章所述，shell会通过`PATH` 环境变量来查找命令。快速查看一下`PATH` 环境变量就可以弄清问题所在。

`PATH` 环境变量被设置成只在一组目录中查找命令。要让shell找到test1脚本，只需采取以下两种作法：

- 将shell脚本文件所处的目录添加到`PATH` 环境变量中；
- 在提示符中用绝对或相对文件路径来引用shell脚本文件。

采用第二种：

```
$ ./test1

bash: ./test1: Permission denied
```

> 现在shell找到了脚本文件，但还有一个问题。shell指明了你还没有执行文件的权限。

给用户添加执行权限：

```
$ chmod u+x test1
```

<b>显示消息(打印)</b>

文本消息来告诉脚本用户脚本正在做什么, 可以通过`echo` 命令来实现:

```
$ echo This is a test

This is a test
```

> 注意，默认情况下，不需要使用引号将要显示的文本字符串划定出来。
>
> `echo` 命令可用单引号或双引号来划定文本字符串。如果在字符串中用到了它们，你需要在文本中使用其中一种引号，而用另外一种来将字符串划定起来。

`-n` 参数， 把文本字符串和命令输出显示在同一行：

```
echo -n "The time and date are: "
```

### 11.2  变量

